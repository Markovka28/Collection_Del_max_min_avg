#                                             # ЛЕКЦИЯ(таблицы)
# import seaborn as sns
# import pandas as pd
# df = pd.read_csv('sample_data/california_housing_train.csv')  # прочесть
# df.head(n=10)           # функция чтобы вывести таблицу, n=10 количество выводимых строк
# df.tail(n=2)            # функция выводит последние стрки в данном случае последние 2, n = 2
# df.shape()              # посмотреть сколько столбцов и строк в таблице, (1700, 9) 1700 строк и 9 столбцов
# df.isnull().sum()       # посмотреть сколько НЕнулевых значений, .sum() количество их общей суммы
# df.dtypes()             # посмотреть тип данных столбца
# df.columns()            # получение всех столбцов (список с названием)

# # ВЫБОРКА ДАННЫХ
# df['ЧЕРЕЗ ЗАПЯТУЮ УКАЗЫВАЮТСЯ СТОЛБЦЫ ИЛИ СТРОКИ КОТОРЫЕ НЕОБХОДИМО ВЫВЕСТИ']
# df[df['hous'] < 20]             # выводит столбец у по которому возраст человека < 20
# df[df['hous'] < 20]['total']    # вывод какого то условия
# # & - выполнение одноверменно всех условий
# # | - выполнение хотябы одного условия

# # РАБОТА СО СТАТИСТИКОЙ
# print(df['population'].max())       # максимальное значение столбца
# print(df['population'].sum())       # просуммировать все значения
# df.describe()                       # все данные таблицы для анализа что находится

# # ИЗОБРАЖЕНИЕ СТАТ ОТНОШЕНИЙ
# sns.scatterplot(data = df, x = 'long', y = 'latitude') # изображение точек долготы по отношению к широте
# # sns - обращение к библиотеке seaborn
# # x ='long', y = 'latitude' указываем с какими столбцами работаем

# cols = ['pop', 'media', 'hous']     # создан список, содержащий определенные столбцы
# g = sns.PairGrid(df[cols])          # в переменную g передаем таблицу со значениями столбцов
# g.map(sns.scatterplot)              # все будем показывать с помощью функции map

                                            #СЕМИНАР (графики)
                                            
""" 
import pandas as pd
import random
lst = ['robot'] * 10
lst += ['human'] * 10
random.shuffle(lst)
print(*enumerate(lst), sep='\n')            # вывод пронумерованного списка
data = list(zip('robot', 'human')) 
dframe = pd.DataFrame(data, columns=['robot', 'human'])
print(dframe) 
"""
                                            
                                            
# #Операции над изменяемыми множествами:

# s.update(t, ...), s |= t | ... – добавить в данное множество элементы из других множеств
# s.intersection_update(t, ...), s &= t & ... – оставить в данном множестве только те элементы, которые есть и в других множествах
# s.difference_update(t, ...), s -= t | ... – удалить из данного множества те элементы, которые есть в других множествах
# s.symmetric_difference_update(t), s ^= t – оставить или добавить в s элементы, которые есть либо в s, либо в t, но не в обоих множествах
# s.add(element) – добавить новый элемент в множество
# s.remove(element) – удалить элемент из множества; если такого элемента нет, возникает исключение KeyError
# s.discard(element) – удалить элемент из множества, если он в нём находится
# s.pop() – удалить из множества и вернуть произвольный элемент; если множество пустое, возникает исключение KeyError
# s.clear() – удалить все элементы множества.

# #Какие операции можно производить над множествами
# set([iterable]), frozenset([iterable]) – создание множества (пустого или из элементов итерабельного объекта)
# len(s) – количество элементов множества
# x in s, x not in s – проверка нахождения элемента в множестве
# s.isdisjoint(t) – проверка того, что данное множество не имеет общих элементов с заданным
# s.issubset(t), s <= t – проверка того, что все элементы множества s являются элементами множества t
# s < t – проверка того, что s <= t и s != t
# s.isuperset(t), s >= t – проверка того, что все элементы множества t являются элементами множества s
# s > t – проверка того, что s >= t и s != t
# s.union(t, ...), s | t | ... – создание нового множества, которое является объединением данных множеств
# s.intersection(t, ...), s & t & ... – создание нового множества, которое является пересечением данных множеств
# s.difference(t, ...), s - t - ... – создание нового множества, которое является разницей данных множеств
# s.symmetric_difference(t), s ^ t – создание нового множества, которое является симметрической разницей данных множеств (то есть, разница объединения и пересечения множеств)
# s.copy() – неполная копия множества s

# #Операции над изменяемыми множествами:

# s.update(t, ...), s |= t | ... – добавить в данное множество элементы из других множеств
# s.intersection_update(t, ...), s &= t & ... – оставить в данном множестве только те элементы, которые есть и в других множествах
# s.difference_update(t, ...), s -= t | ... – удалить из данного множества те элементы, которые есть в других множествах
# s.symmetric_difference_update(t), s ^= t – оставить или добавить в s элементы, которые есть либо в s, либо в t, но не в обоих множествах
# s.add(element) – добавить новый элемент в множество
# s.remove(element) – удалить элемент из множества; если такого элемента нет, возникает исключение KeyError
# s.discard(element) – удалить элемент из множества, если он в нём находится
# s.pop() – удалить из множества и вернуть произвольный элемент; если множество пустое, возникает исключение KeyError
# s.clear() – удалить все элементы множества.

# #Код ниже показывает, как отсортировать список людей по возрасту:

# users = [{'age': 30}, {'age': 20}, {'age': 10}]
# users.sort(key=lambda user: user['age'])
# >>> [{'age': 10}, {'age': 20}, {'age': 30}]


# класс это чертеж по которому создаются экземпляры классы

class Fruit:
    def __init__(self, name, weight, country, flavour):
        self.name = name # атрибуты класса его свойства которе ему принадлежат
        self.weight = weight
        self.country = country
        self.flavour =  flavour
    
    def what(self,):
        print(f'Name - {self.name} from {self.country}')

pine_apple = Fruit('pineapple', 1, 'Africa', 'sweet')
pine_apple.what()

class Veg(Fruit):
    def print_name(self):
        print(self.name)
        
tomato = Veg('tomato', 0.5, 'Europe', 'stra')
tomato.what

